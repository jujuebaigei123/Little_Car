// Generated by gencpp from file mqtt_commx/controls.msg
// DO NOT EDIT!


#ifndef MQTT_COMMX_MESSAGE_CONTROLS_H
#define MQTT_COMMX_MESSAGE_CONTROLS_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <mqtt_commx/path_point.h>

namespace mqtt_commx
{
template <class ContainerAllocator>
struct controls_
{
  typedef controls_<ContainerAllocator> Type;

  controls_()
    : msgType()
    , agvId()
    , timestamp(0)
    , taskId(0)
    , taskType(0)
    , targetName()
    , targetX(0.0)
    , targetY(0.0)
    , targetHA(0.0)
    , cargoLength(0.0)
    , cargoWidth(0.0)
    , cargoWeight(0.0)
    , cargoId()
    , wheelBase(0.0)
    , subtaskCount(0)
    , subtaskIndex(0)
    , subtaskAction(0)
    , pathLength(0)
    , path()
    , value(0)
    , channelId(0)
    , cmd(0)
    , timeSec(0)
    , addr()
    , cmdId(0)
    , ctrlType()
    , stopPosX(0.0)
    , stopPosY(0.0)
    , stopPosHA(0.0)
    , lightStatus(0)
    , lightType(0)
    , lightLeftTime(0)
    , intersectionId(0)  {
    }
  controls_(const ContainerAllocator& _alloc)
    : msgType(_alloc)
    , agvId(_alloc)
    , timestamp(0)
    , taskId(0)
    , taskType(0)
    , targetName(_alloc)
    , targetX(0.0)
    , targetY(0.0)
    , targetHA(0.0)
    , cargoLength(0.0)
    , cargoWidth(0.0)
    , cargoWeight(0.0)
    , cargoId(_alloc)
    , wheelBase(0.0)
    , subtaskCount(0)
    , subtaskIndex(0)
    , subtaskAction(0)
    , pathLength(0)
    , path(_alloc)
    , value(0)
    , channelId(0)
    , cmd(0)
    , timeSec(0)
    , addr(_alloc)
    , cmdId(0)
    , ctrlType(_alloc)
    , stopPosX(0.0)
    , stopPosY(0.0)
    , stopPosHA(0.0)
    , lightStatus(0)
    , lightType(0)
    , lightLeftTime(0)
    , intersectionId(0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _msgType_type;
  _msgType_type msgType;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _agvId_type;
  _agvId_type agvId;

   typedef int64_t _timestamp_type;
  _timestamp_type timestamp;

   typedef int32_t _taskId_type;
  _taskId_type taskId;

   typedef int32_t _taskType_type;
  _taskType_type taskType;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _targetName_type;
  _targetName_type targetName;

   typedef double _targetX_type;
  _targetX_type targetX;

   typedef double _targetY_type;
  _targetY_type targetY;

   typedef double _targetHA_type;
  _targetHA_type targetHA;

   typedef double _cargoLength_type;
  _cargoLength_type cargoLength;

   typedef double _cargoWidth_type;
  _cargoWidth_type cargoWidth;

   typedef double _cargoWeight_type;
  _cargoWeight_type cargoWeight;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _cargoId_type;
  _cargoId_type cargoId;

   typedef double _wheelBase_type;
  _wheelBase_type wheelBase;

   typedef int32_t _subtaskCount_type;
  _subtaskCount_type subtaskCount;

   typedef int32_t _subtaskIndex_type;
  _subtaskIndex_type subtaskIndex;

   typedef int32_t _subtaskAction_type;
  _subtaskAction_type subtaskAction;

   typedef int32_t _pathLength_type;
  _pathLength_type pathLength;

   typedef std::vector< ::mqtt_commx::path_point_<ContainerAllocator> , typename std::allocator_traits<ContainerAllocator>::template rebind_alloc< ::mqtt_commx::path_point_<ContainerAllocator> >> _path_type;
  _path_type path;

   typedef int32_t _value_type;
  _value_type value;

   typedef int32_t _channelId_type;
  _channelId_type channelId;

   typedef int32_t _cmd_type;
  _cmd_type cmd;

   typedef int32_t _timeSec_type;
  _timeSec_type timeSec;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _addr_type;
  _addr_type addr;

   typedef int32_t _cmdId_type;
  _cmdId_type cmdId;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _ctrlType_type;
  _ctrlType_type ctrlType;

   typedef double _stopPosX_type;
  _stopPosX_type stopPosX;

   typedef double _stopPosY_type;
  _stopPosY_type stopPosY;

   typedef double _stopPosHA_type;
  _stopPosHA_type stopPosHA;

   typedef int32_t _lightStatus_type;
  _lightStatus_type lightStatus;

   typedef int32_t _lightType_type;
  _lightType_type lightType;

   typedef int32_t _lightLeftTime_type;
  _lightLeftTime_type lightLeftTime;

   typedef int32_t _intersectionId_type;
  _intersectionId_type intersectionId;





  typedef boost::shared_ptr< ::mqtt_commx::controls_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mqtt_commx::controls_<ContainerAllocator> const> ConstPtr;

}; // struct controls_

typedef ::mqtt_commx::controls_<std::allocator<void> > controls;

typedef boost::shared_ptr< ::mqtt_commx::controls > controlsPtr;
typedef boost::shared_ptr< ::mqtt_commx::controls const> controlsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mqtt_commx::controls_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mqtt_commx::controls_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mqtt_commx::controls_<ContainerAllocator1> & lhs, const ::mqtt_commx::controls_<ContainerAllocator2> & rhs)
{
  return lhs.msgType == rhs.msgType &&
    lhs.agvId == rhs.agvId &&
    lhs.timestamp == rhs.timestamp &&
    lhs.taskId == rhs.taskId &&
    lhs.taskType == rhs.taskType &&
    lhs.targetName == rhs.targetName &&
    lhs.targetX == rhs.targetX &&
    lhs.targetY == rhs.targetY &&
    lhs.targetHA == rhs.targetHA &&
    lhs.cargoLength == rhs.cargoLength &&
    lhs.cargoWidth == rhs.cargoWidth &&
    lhs.cargoWeight == rhs.cargoWeight &&
    lhs.cargoId == rhs.cargoId &&
    lhs.wheelBase == rhs.wheelBase &&
    lhs.subtaskCount == rhs.subtaskCount &&
    lhs.subtaskIndex == rhs.subtaskIndex &&
    lhs.subtaskAction == rhs.subtaskAction &&
    lhs.pathLength == rhs.pathLength &&
    lhs.path == rhs.path &&
    lhs.value == rhs.value &&
    lhs.channelId == rhs.channelId &&
    lhs.cmd == rhs.cmd &&
    lhs.timeSec == rhs.timeSec &&
    lhs.addr == rhs.addr &&
    lhs.cmdId == rhs.cmdId &&
    lhs.ctrlType == rhs.ctrlType &&
    lhs.stopPosX == rhs.stopPosX &&
    lhs.stopPosY == rhs.stopPosY &&
    lhs.stopPosHA == rhs.stopPosHA &&
    lhs.lightStatus == rhs.lightStatus &&
    lhs.lightType == rhs.lightType &&
    lhs.lightLeftTime == rhs.lightLeftTime &&
    lhs.intersectionId == rhs.intersectionId;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mqtt_commx::controls_<ContainerAllocator1> & lhs, const ::mqtt_commx::controls_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mqtt_commx

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mqtt_commx::controls_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mqtt_commx::controls_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mqtt_commx::controls_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mqtt_commx::controls_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mqtt_commx::controls_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mqtt_commx::controls_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mqtt_commx::controls_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fe7b7fdca90c630418f47e94ec5b0182";
  }

  static const char* value(const ::mqtt_commx::controls_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfe7b7fdca90c6304ULL;
  static const uint64_t static_value2 = 0x18f47e94ec5b0182ULL;
};

template<class ContainerAllocator>
struct DataType< ::mqtt_commx::controls_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mqtt_commx/controls";
  }

  static const char* value(const ::mqtt_commx::controls_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mqtt_commx::controls_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string msgType\n"
"string agvId\n"
"int64 timestamp\n"
"\n"
"#task\n"
"int32 taskId\n"
"int32 taskType \n"
"string targetName \n"
"float64 targetX\n"
"float64 targetY\n"
"float64 targetHA\n"
"float64 cargoLength\n"
"float64 cargoWidth\n"
"float64 cargoWeight\n"
"string cargoId\n"
"float64 wheelBase\n"
"int32 subtaskCount\n"
"int32 subtaskIndex\n"
"int32 subtaskAction\n"
"int32 pathLength\n"
"path_point[] path\n"
"\n"
"# sync\n"
"int32 value\n"
"\n"
"# video\n"
"int32 channelId\n"
"int32 cmd       \n"
"int32 timeSec\n"
"string addr\n"
"\n"
"# ctrl\n"
"int32 cmdId\n"
"string ctrlType\n"
"float64 stopPosX\n"
"float64 stopPosY\n"
"float64 stopPosHA \n"
"int32 lightStatus\n"
"int32 lightType\n"
"int32 lightLeftTime\n"
"int32 intersectionId\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"================================================================================\n"
"MSG: mqtt_commx/path_point\n"
"string id\n"
"float64 pointX\n"
"float64 pointY\n"
"float64 pointHA\n"
"float32 vehSpeed\n"
;
  }

  static const char* value(const ::mqtt_commx::controls_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mqtt_commx::controls_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.msgType);
      stream.next(m.agvId);
      stream.next(m.timestamp);
      stream.next(m.taskId);
      stream.next(m.taskType);
      stream.next(m.targetName);
      stream.next(m.targetX);
      stream.next(m.targetY);
      stream.next(m.targetHA);
      stream.next(m.cargoLength);
      stream.next(m.cargoWidth);
      stream.next(m.cargoWeight);
      stream.next(m.cargoId);
      stream.next(m.wheelBase);
      stream.next(m.subtaskCount);
      stream.next(m.subtaskIndex);
      stream.next(m.subtaskAction);
      stream.next(m.pathLength);
      stream.next(m.path);
      stream.next(m.value);
      stream.next(m.channelId);
      stream.next(m.cmd);
      stream.next(m.timeSec);
      stream.next(m.addr);
      stream.next(m.cmdId);
      stream.next(m.ctrlType);
      stream.next(m.stopPosX);
      stream.next(m.stopPosY);
      stream.next(m.stopPosHA);
      stream.next(m.lightStatus);
      stream.next(m.lightType);
      stream.next(m.lightLeftTime);
      stream.next(m.intersectionId);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct controls_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mqtt_commx::controls_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mqtt_commx::controls_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "msgType: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.msgType);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "agvId: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.agvId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "timestamp: ";
    Printer<int64_t>::stream(s, indent + "  ", v.timestamp);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "taskId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.taskId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "taskType: ";
    Printer<int32_t>::stream(s, indent + "  ", v.taskType);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "targetName: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.targetName);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "targetX: ";
    Printer<double>::stream(s, indent + "  ", v.targetX);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "targetY: ";
    Printer<double>::stream(s, indent + "  ", v.targetY);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "targetHA: ";
    Printer<double>::stream(s, indent + "  ", v.targetHA);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cargoLength: ";
    Printer<double>::stream(s, indent + "  ", v.cargoLength);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cargoWidth: ";
    Printer<double>::stream(s, indent + "  ", v.cargoWidth);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cargoWeight: ";
    Printer<double>::stream(s, indent + "  ", v.cargoWeight);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cargoId: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.cargoId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "wheelBase: ";
    Printer<double>::stream(s, indent + "  ", v.wheelBase);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "subtaskCount: ";
    Printer<int32_t>::stream(s, indent + "  ", v.subtaskCount);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "subtaskIndex: ";
    Printer<int32_t>::stream(s, indent + "  ", v.subtaskIndex);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "subtaskAction: ";
    Printer<int32_t>::stream(s, indent + "  ", v.subtaskAction);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pathLength: ";
    Printer<int32_t>::stream(s, indent + "  ", v.pathLength);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "path: ";
    if (v.path.empty() || false)
      s << "[";
    for (size_t i = 0; i < v.path.size(); ++i)
    {
      if (false && i > 0)
        s << ", ";
      else if (!false)
        s << std::endl << indent << "  -";
      Printer< ::mqtt_commx::path_point_<ContainerAllocator> >::stream(s, false ? std::string() : indent + "    ", v.path[i]);
    }
    if (v.path.empty() || false)
      s << "]";
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "value: ";
    Printer<int32_t>::stream(s, indent + "  ", v.value);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "channelId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.channelId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cmd: ";
    Printer<int32_t>::stream(s, indent + "  ", v.cmd);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "timeSec: ";
    Printer<int32_t>::stream(s, indent + "  ", v.timeSec);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "addr: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.addr);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "cmdId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.cmdId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "ctrlType: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.ctrlType);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "stopPosX: ";
    Printer<double>::stream(s, indent + "  ", v.stopPosX);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "stopPosY: ";
    Printer<double>::stream(s, indent + "  ", v.stopPosY);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "stopPosHA: ";
    Printer<double>::stream(s, indent + "  ", v.stopPosHA);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "lightStatus: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lightStatus);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "lightType: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lightType);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "lightLeftTime: ";
    Printer<int32_t>::stream(s, indent + "  ", v.lightLeftTime);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "intersectionId: ";
    Printer<int32_t>::stream(s, indent + "  ", v.intersectionId);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MQTT_COMMX_MESSAGE_CONTROLS_H
