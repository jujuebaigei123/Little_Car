// Generated by gencpp from file mqtt_comm/resp_agvstate.msg
// DO NOT EDIT!


#ifndef MQTT_COMM_MESSAGE_RESP_AGVSTATE_H
#define MQTT_COMM_MESSAGE_RESP_AGVSTATE_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace mqtt_comm
{
template <class ContainerAllocator>
struct resp_agvstate_
{
  typedef resp_agvstate_<ContainerAllocator> Type;

  resp_agvstate_()
    : msgType()
    , timestamp(0)
    , version()
    , mileage(0.0)
    , batterySOH(0.0)
    , batterySOC(0.0)
    , batteryVoltage(0.0)
    , batteryCurrent(0.0)
    , batterytemperature(0)
    , charge_state(0)
    , vehSpeed(0.0)
    , pointHA(0.0)
    , pointX(0.0)
    , pointY(0.0)
    , workPointid()
    , steerControlMode(0)
    , vehCtrlMode(0)
    , autoDriveEnable(0)
    , pitchAngle(0.0)
    , azimuthAngle(0.0)
    , taskId()
    , taskStatus(0)
    , errCode()  {
    }
  resp_agvstate_(const ContainerAllocator& _alloc)
    : msgType(_alloc)
    , timestamp(0)
    , version(_alloc)
    , mileage(0.0)
    , batterySOH(0.0)
    , batterySOC(0.0)
    , batteryVoltage(0.0)
    , batteryCurrent(0.0)
    , batterytemperature(0)
    , charge_state(0)
    , vehSpeed(0.0)
    , pointHA(0.0)
    , pointX(0.0)
    , pointY(0.0)
    , workPointid(_alloc)
    , steerControlMode(0)
    , vehCtrlMode(0)
    , autoDriveEnable(0)
    , pitchAngle(0.0)
    , azimuthAngle(0.0)
    , taskId(_alloc)
    , taskStatus(0)
    , errCode(_alloc)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _msgType_type;
  _msgType_type msgType;

   typedef int64_t _timestamp_type;
  _timestamp_type timestamp;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _version_type;
  _version_type version;

   typedef double _mileage_type;
  _mileage_type mileage;

   typedef double _batterySOH_type;
  _batterySOH_type batterySOH;

   typedef double _batterySOC_type;
  _batterySOC_type batterySOC;

   typedef double _batteryVoltage_type;
  _batteryVoltage_type batteryVoltage;

   typedef double _batteryCurrent_type;
  _batteryCurrent_type batteryCurrent;

   typedef int32_t _batterytemperature_type;
  _batterytemperature_type batterytemperature;

   typedef int32_t _charge_state_type;
  _charge_state_type charge_state;

   typedef float _vehSpeed_type;
  _vehSpeed_type vehSpeed;

   typedef float _pointHA_type;
  _pointHA_type pointHA;

   typedef double _pointX_type;
  _pointX_type pointX;

   typedef double _pointY_type;
  _pointY_type pointY;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _workPointid_type;
  _workPointid_type workPointid;

   typedef int32_t _steerControlMode_type;
  _steerControlMode_type steerControlMode;

   typedef int32_t _vehCtrlMode_type;
  _vehCtrlMode_type vehCtrlMode;

   typedef int32_t _autoDriveEnable_type;
  _autoDriveEnable_type autoDriveEnable;

   typedef float _pitchAngle_type;
  _pitchAngle_type pitchAngle;

   typedef float _azimuthAngle_type;
  _azimuthAngle_type azimuthAngle;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _taskId_type;
  _taskId_type taskId;

   typedef int32_t _taskStatus_type;
  _taskStatus_type taskStatus;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _errCode_type;
  _errCode_type errCode;





  typedef boost::shared_ptr< ::mqtt_comm::resp_agvstate_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::mqtt_comm::resp_agvstate_<ContainerAllocator> const> ConstPtr;

}; // struct resp_agvstate_

typedef ::mqtt_comm::resp_agvstate_<std::allocator<void> > resp_agvstate;

typedef boost::shared_ptr< ::mqtt_comm::resp_agvstate > resp_agvstatePtr;
typedef boost::shared_ptr< ::mqtt_comm::resp_agvstate const> resp_agvstateConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::mqtt_comm::resp_agvstate_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::mqtt_comm::resp_agvstate_<ContainerAllocator1> & lhs, const ::mqtt_comm::resp_agvstate_<ContainerAllocator2> & rhs)
{
  return lhs.msgType == rhs.msgType &&
    lhs.timestamp == rhs.timestamp &&
    lhs.version == rhs.version &&
    lhs.mileage == rhs.mileage &&
    lhs.batterySOH == rhs.batterySOH &&
    lhs.batterySOC == rhs.batterySOC &&
    lhs.batteryVoltage == rhs.batteryVoltage &&
    lhs.batteryCurrent == rhs.batteryCurrent &&
    lhs.batterytemperature == rhs.batterytemperature &&
    lhs.charge_state == rhs.charge_state &&
    lhs.vehSpeed == rhs.vehSpeed &&
    lhs.pointHA == rhs.pointHA &&
    lhs.pointX == rhs.pointX &&
    lhs.pointY == rhs.pointY &&
    lhs.workPointid == rhs.workPointid &&
    lhs.steerControlMode == rhs.steerControlMode &&
    lhs.vehCtrlMode == rhs.vehCtrlMode &&
    lhs.autoDriveEnable == rhs.autoDriveEnable &&
    lhs.pitchAngle == rhs.pitchAngle &&
    lhs.azimuthAngle == rhs.azimuthAngle &&
    lhs.taskId == rhs.taskId &&
    lhs.taskStatus == rhs.taskStatus &&
    lhs.errCode == rhs.errCode;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::mqtt_comm::resp_agvstate_<ContainerAllocator1> & lhs, const ::mqtt_comm::resp_agvstate_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace mqtt_comm

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::mqtt_comm::resp_agvstate_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::mqtt_comm::resp_agvstate_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::mqtt_comm::resp_agvstate_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "9afde21e9d1bc354804e4cf18e51c787";
  }

  static const char* value(const ::mqtt_comm::resp_agvstate_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x9afde21e9d1bc354ULL;
  static const uint64_t static_value2 = 0x804e4cf18e51c787ULL;
};

template<class ContainerAllocator>
struct DataType< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "mqtt_comm/resp_agvstate";
  }

  static const char* value(const ::mqtt_comm::resp_agvstate_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string msgType\n"
"int64 timestamp\n"
"string version\n"
"\n"
"float64 mileage\n"
"float64 batterySOH\n"
"float64 batterySOC\n"
"float64 batteryVoltage\n"
"float64 batteryCurrent\n"
"int32 batterytemperature\n"
"int32 charge_state\n"
"\n"
"float32 vehSpeed    \n"
"float32 pointHA\n"
"float64 pointX\n"
"float64 pointY\n"
"string workPointid\n"
"\n"
"int32 steerControlMode\n"
"int32 vehCtrlMode	\n"
"int32 autoDriveEnable	\n"
"\n"
"float32 pitchAngle\n"
"float32 azimuthAngle\n"
"\n"
"string taskId\n"
"int32 taskStatus\n"
"string errCode\n"
"\n"
;
  }

  static const char* value(const ::mqtt_comm::resp_agvstate_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.msgType);
      stream.next(m.timestamp);
      stream.next(m.version);
      stream.next(m.mileage);
      stream.next(m.batterySOH);
      stream.next(m.batterySOC);
      stream.next(m.batteryVoltage);
      stream.next(m.batteryCurrent);
      stream.next(m.batterytemperature);
      stream.next(m.charge_state);
      stream.next(m.vehSpeed);
      stream.next(m.pointHA);
      stream.next(m.pointX);
      stream.next(m.pointY);
      stream.next(m.workPointid);
      stream.next(m.steerControlMode);
      stream.next(m.vehCtrlMode);
      stream.next(m.autoDriveEnable);
      stream.next(m.pitchAngle);
      stream.next(m.azimuthAngle);
      stream.next(m.taskId);
      stream.next(m.taskStatus);
      stream.next(m.errCode);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct resp_agvstate_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::mqtt_comm::resp_agvstate_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::mqtt_comm::resp_agvstate_<ContainerAllocator>& v)
  {
    if (false || !indent.empty())
      s << std::endl;
    s << indent << "msgType: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.msgType);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "timestamp: ";
    Printer<int64_t>::stream(s, indent + "  ", v.timestamp);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "version: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.version);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "mileage: ";
    Printer<double>::stream(s, indent + "  ", v.mileage);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "batterySOH: ";
    Printer<double>::stream(s, indent + "  ", v.batterySOH);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "batterySOC: ";
    Printer<double>::stream(s, indent + "  ", v.batterySOC);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "batteryVoltage: ";
    Printer<double>::stream(s, indent + "  ", v.batteryVoltage);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "batteryCurrent: ";
    Printer<double>::stream(s, indent + "  ", v.batteryCurrent);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "batterytemperature: ";
    Printer<int32_t>::stream(s, indent + "  ", v.batterytemperature);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "charge_state: ";
    Printer<int32_t>::stream(s, indent + "  ", v.charge_state);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "vehSpeed: ";
    Printer<float>::stream(s, indent + "  ", v.vehSpeed);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pointHA: ";
    Printer<float>::stream(s, indent + "  ", v.pointHA);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pointX: ";
    Printer<double>::stream(s, indent + "  ", v.pointX);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pointY: ";
    Printer<double>::stream(s, indent + "  ", v.pointY);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "workPointid: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.workPointid);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "steerControlMode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.steerControlMode);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "vehCtrlMode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.vehCtrlMode);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "autoDriveEnable: ";
    Printer<int32_t>::stream(s, indent + "  ", v.autoDriveEnable);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "pitchAngle: ";
    Printer<float>::stream(s, indent + "  ", v.pitchAngle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "azimuthAngle: ";
    Printer<float>::stream(s, indent + "  ", v.azimuthAngle);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "taskId: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.taskId);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "taskStatus: ";
    Printer<int32_t>::stream(s, indent + "  ", v.taskStatus);
    if (true || !indent.empty())
      s << std::endl;
    s << indent << "errCode: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.errCode);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MQTT_COMM_MESSAGE_RESP_AGVSTATE_H
