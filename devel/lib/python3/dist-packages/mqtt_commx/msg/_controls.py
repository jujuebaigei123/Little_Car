# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from mqtt_commx/controls.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import mqtt_commx.msg

class controls(genpy.Message):
  _md5sum = "fe7b7fdca90c630418f47e94ec5b0182"
  _type = "mqtt_commx/controls"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """string msgType
string agvId
int64 timestamp

#task
int32 taskId
int32 taskType 
string targetName 
float64 targetX
float64 targetY
float64 targetHA
float64 cargoLength
float64 cargoWidth
float64 cargoWeight
string cargoId
float64 wheelBase
int32 subtaskCount
int32 subtaskIndex
int32 subtaskAction
int32 pathLength
path_point[] path

# sync
int32 value

# video
int32 channelId
int32 cmd       
int32 timeSec
string addr

# ctrl
int32 cmdId
string ctrlType
float64 stopPosX
float64 stopPosY
float64 stopPosHA 
int32 lightStatus
int32 lightType
int32 lightLeftTime
int32 intersectionId






================================================================================
MSG: mqtt_commx/path_point
string id
float64 pointX
float64 pointY
float64 pointHA
float32 vehSpeed
"""
  __slots__ = ['msgType','agvId','timestamp','taskId','taskType','targetName','targetX','targetY','targetHA','cargoLength','cargoWidth','cargoWeight','cargoId','wheelBase','subtaskCount','subtaskIndex','subtaskAction','pathLength','path','value','channelId','cmd','timeSec','addr','cmdId','ctrlType','stopPosX','stopPosY','stopPosHA','lightStatus','lightType','lightLeftTime','intersectionId']
  _slot_types = ['string','string','int64','int32','int32','string','float64','float64','float64','float64','float64','float64','string','float64','int32','int32','int32','int32','mqtt_commx/path_point[]','int32','int32','int32','int32','string','int32','string','float64','float64','float64','int32','int32','int32','int32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       msgType,agvId,timestamp,taskId,taskType,targetName,targetX,targetY,targetHA,cargoLength,cargoWidth,cargoWeight,cargoId,wheelBase,subtaskCount,subtaskIndex,subtaskAction,pathLength,path,value,channelId,cmd,timeSec,addr,cmdId,ctrlType,stopPosX,stopPosY,stopPosHA,lightStatus,lightType,lightLeftTime,intersectionId

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(controls, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.msgType is None:
        self.msgType = ''
      if self.agvId is None:
        self.agvId = ''
      if self.timestamp is None:
        self.timestamp = 0
      if self.taskId is None:
        self.taskId = 0
      if self.taskType is None:
        self.taskType = 0
      if self.targetName is None:
        self.targetName = ''
      if self.targetX is None:
        self.targetX = 0.
      if self.targetY is None:
        self.targetY = 0.
      if self.targetHA is None:
        self.targetHA = 0.
      if self.cargoLength is None:
        self.cargoLength = 0.
      if self.cargoWidth is None:
        self.cargoWidth = 0.
      if self.cargoWeight is None:
        self.cargoWeight = 0.
      if self.cargoId is None:
        self.cargoId = ''
      if self.wheelBase is None:
        self.wheelBase = 0.
      if self.subtaskCount is None:
        self.subtaskCount = 0
      if self.subtaskIndex is None:
        self.subtaskIndex = 0
      if self.subtaskAction is None:
        self.subtaskAction = 0
      if self.pathLength is None:
        self.pathLength = 0
      if self.path is None:
        self.path = []
      if self.value is None:
        self.value = 0
      if self.channelId is None:
        self.channelId = 0
      if self.cmd is None:
        self.cmd = 0
      if self.timeSec is None:
        self.timeSec = 0
      if self.addr is None:
        self.addr = ''
      if self.cmdId is None:
        self.cmdId = 0
      if self.ctrlType is None:
        self.ctrlType = ''
      if self.stopPosX is None:
        self.stopPosX = 0.
      if self.stopPosY is None:
        self.stopPosY = 0.
      if self.stopPosHA is None:
        self.stopPosHA = 0.
      if self.lightStatus is None:
        self.lightStatus = 0
      if self.lightType is None:
        self.lightType = 0
      if self.lightLeftTime is None:
        self.lightLeftTime = 0
      if self.intersectionId is None:
        self.intersectionId = 0
    else:
      self.msgType = ''
      self.agvId = ''
      self.timestamp = 0
      self.taskId = 0
      self.taskType = 0
      self.targetName = ''
      self.targetX = 0.
      self.targetY = 0.
      self.targetHA = 0.
      self.cargoLength = 0.
      self.cargoWidth = 0.
      self.cargoWeight = 0.
      self.cargoId = ''
      self.wheelBase = 0.
      self.subtaskCount = 0
      self.subtaskIndex = 0
      self.subtaskAction = 0
      self.pathLength = 0
      self.path = []
      self.value = 0
      self.channelId = 0
      self.cmd = 0
      self.timeSec = 0
      self.addr = ''
      self.cmdId = 0
      self.ctrlType = ''
      self.stopPosX = 0.
      self.stopPosY = 0.
      self.stopPosHA = 0.
      self.lightStatus = 0
      self.lightType = 0
      self.lightLeftTime = 0
      self.intersectionId = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.msgType
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.agvId
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_q2i().pack(_x.timestamp, _x.taskId, _x.taskType))
      _x = self.targetName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_6d().pack(_x.targetX, _x.targetY, _x.targetHA, _x.cargoLength, _x.cargoWidth, _x.cargoWeight))
      _x = self.cargoId
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_d4i().pack(_x.wheelBase, _x.subtaskCount, _x.subtaskIndex, _x.subtaskAction, _x.pathLength))
      length = len(self.path)
      buff.write(_struct_I.pack(length))
      for val1 in self.path:
        _x = val1.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_3df().pack(_x.pointX, _x.pointY, _x.pointHA, _x.vehSpeed))
      _x = self
      buff.write(_get_struct_4i().pack(_x.value, _x.channelId, _x.cmd, _x.timeSec))
      _x = self.addr
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.cmdId
      buff.write(_get_struct_i().pack(_x))
      _x = self.ctrlType
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d4i().pack(_x.stopPosX, _x.stopPosY, _x.stopPosHA, _x.lightStatus, _x.lightType, _x.lightLeftTime, _x.intersectionId))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.path is None:
        self.path = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.msgType = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.msgType = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.agvId = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.agvId = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.timestamp, _x.taskId, _x.taskType,) = _get_struct_q2i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.targetName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.targetName = str[start:end]
      _x = self
      start = end
      end += 48
      (_x.targetX, _x.targetY, _x.targetHA, _x.cargoLength, _x.cargoWidth, _x.cargoWeight,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.cargoId = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.cargoId = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.wheelBase, _x.subtaskCount, _x.subtaskIndex, _x.subtaskAction, _x.pathLength,) = _get_struct_d4i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.path = []
      for i in range(0, length):
        val1 = mqtt_commx.msg.path_point()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.id = str[start:end]
        _x = val1
        start = end
        end += 28
        (_x.pointX, _x.pointY, _x.pointHA, _x.vehSpeed,) = _get_struct_3df().unpack(str[start:end])
        self.path.append(val1)
      _x = self
      start = end
      end += 16
      (_x.value, _x.channelId, _x.cmd, _x.timeSec,) = _get_struct_4i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.addr = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.addr = str[start:end]
      start = end
      end += 4
      (self.cmdId,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.ctrlType = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.ctrlType = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.stopPosX, _x.stopPosY, _x.stopPosHA, _x.lightStatus, _x.lightType, _x.lightLeftTime, _x.intersectionId,) = _get_struct_3d4i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.msgType
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.agvId
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_q2i().pack(_x.timestamp, _x.taskId, _x.taskType))
      _x = self.targetName
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_6d().pack(_x.targetX, _x.targetY, _x.targetHA, _x.cargoLength, _x.cargoWidth, _x.cargoWeight))
      _x = self.cargoId
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_d4i().pack(_x.wheelBase, _x.subtaskCount, _x.subtaskIndex, _x.subtaskAction, _x.pathLength))
      length = len(self.path)
      buff.write(_struct_I.pack(length))
      for val1 in self.path:
        _x = val1.id
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        _x = val1
        buff.write(_get_struct_3df().pack(_x.pointX, _x.pointY, _x.pointHA, _x.vehSpeed))
      _x = self
      buff.write(_get_struct_4i().pack(_x.value, _x.channelId, _x.cmd, _x.timeSec))
      _x = self.addr
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.cmdId
      buff.write(_get_struct_i().pack(_x))
      _x = self.ctrlType
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d4i().pack(_x.stopPosX, _x.stopPosY, _x.stopPosHA, _x.lightStatus, _x.lightType, _x.lightLeftTime, _x.intersectionId))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.path is None:
        self.path = None
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.msgType = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.msgType = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.agvId = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.agvId = str[start:end]
      _x = self
      start = end
      end += 16
      (_x.timestamp, _x.taskId, _x.taskType,) = _get_struct_q2i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.targetName = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.targetName = str[start:end]
      _x = self
      start = end
      end += 48
      (_x.targetX, _x.targetY, _x.targetHA, _x.cargoLength, _x.cargoWidth, _x.cargoWeight,) = _get_struct_6d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.cargoId = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.cargoId = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.wheelBase, _x.subtaskCount, _x.subtaskIndex, _x.subtaskAction, _x.pathLength,) = _get_struct_d4i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.path = []
      for i in range(0, length):
        val1 = mqtt_commx.msg.path_point()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.id = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.id = str[start:end]
        _x = val1
        start = end
        end += 28
        (_x.pointX, _x.pointY, _x.pointHA, _x.vehSpeed,) = _get_struct_3df().unpack(str[start:end])
        self.path.append(val1)
      _x = self
      start = end
      end += 16
      (_x.value, _x.channelId, _x.cmd, _x.timeSec,) = _get_struct_4i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.addr = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.addr = str[start:end]
      start = end
      end += 4
      (self.cmdId,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.ctrlType = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.ctrlType = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.stopPosX, _x.stopPosY, _x.stopPosHA, _x.lightStatus, _x.lightType, _x.lightLeftTime, _x.intersectionId,) = _get_struct_3d4i().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3d4i = None
def _get_struct_3d4i():
    global _struct_3d4i
    if _struct_3d4i is None:
        _struct_3d4i = struct.Struct("<3d4i")
    return _struct_3d4i
_struct_3df = None
def _get_struct_3df():
    global _struct_3df
    if _struct_3df is None:
        _struct_3df = struct.Struct("<3df")
    return _struct_3df
_struct_4i = None
def _get_struct_4i():
    global _struct_4i
    if _struct_4i is None:
        _struct_4i = struct.Struct("<4i")
    return _struct_4i
_struct_6d = None
def _get_struct_6d():
    global _struct_6d
    if _struct_6d is None:
        _struct_6d = struct.Struct("<6d")
    return _struct_6d
_struct_d4i = None
def _get_struct_d4i():
    global _struct_d4i
    if _struct_d4i is None:
        _struct_d4i = struct.Struct("<d4i")
    return _struct_d4i
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_q2i = None
def _get_struct_q2i():
    global _struct_q2i
    if _struct_q2i is None:
        _struct_q2i = struct.Struct("<q2i")
    return _struct_q2i
